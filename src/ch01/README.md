# 1장 리팩터링: 첫 번째 예시

## 목표

- 리팩터링이 무엇인지
- 리팩터링을 왜 하는지
- 리팩터링을 어떻게 하는지

## 1. 예시 프로그램 소개

- 어떤 극단의 공연료 청구서를 출력하는 코드를 예시로 사용한다.
- 이 극단은 공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정한다.
- 공연료와 별개로 포인트를 적립해서 다음에 할인 받을 수도 있다.

## 2. 리팩터링을 왜 하는가(2장)

- 예시 프로그램에서 수정할 부분을 몇 개 발견했다.
    1. 청구 내역을 HTML로 출력하는 기능 추가
    2. 더 많은 장르를 추가하기 용이하도록 변경
- 1번 기능을 구현하려면 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸서 조건에 따라 HTML 태그를 감싸도록 해야 한다. 그러면 `statement()` 함수의 복잡도가 크게 증가하므로 함수의
  복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리할 수도 있다.
- 처음 복사본을 만드는 일은 어렵지 않지만, 이 방식은 추후에 수많은 문제를 야기한다.
- 예를 들어 장르를 추가하거나 공연료 정책이 달라질 때마다 각 복사본이 일관되게 맞춰서 수정해야 한다.
- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가해야 한다.

## 3. 리펙터링의 첫 단계 - 테스트 작성(4장)

- 리팩터링할 코드 영역을 꼼꼼하게 검사해 줄 테스트 코드를 작성한다.
- 리팩터링은 사람이 수행하기 때문에 언제든 실수할 수 있다.
- 리팩터링 과정에서 테스트를 계속 실행하여 실수를 막고 버그를 인지할 수 있게 한다.
- `statement()` 함수는 문자열을 반환하므로 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비하고, 함수 반환값과 비교하여 테스트한다.

## 4. `statement()` 함수 쪼개기 - 함수 추출하기(6.1절)

### 개요

- `statement()` 함수처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작 중 각각의 부분으로 나눌 수 있는 지점을 찾는다.
- 중간의 switch문은 한 번의 공연에 대한 요금을 계산한다. 이는 코드를 분석해서 얻은 정보이다. 이렇게 파악한 정보는 휘발성이 강하므로 코드에 반영하여 잊지 않도록 한다. => 함수 추출하기(6.1절)

### 순서

1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다. (amountFor)
2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
3. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
    - (변수명 변경 - thisAmount => result / perf => aPerformance / play => 임의 변수를 질의 함수로 바꾸기(7.4절))
4. 변수를 다 처리했다면 컴파일한다.
5. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
6. 테스트한다.
7. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다.
    - (thisAmount => inline)

### 점검

- `statement()` 함수는 7줄이고, 출력할 문장을 생성하는 일만 한다.
- 이외의 계산 로직은 모두 보조 함수로 분리했다.
- 결과적으로 각 계산 과정은 물론 전체 흐름을 이해하기가 훨씬 쉬워졌다.
- (성능 문제는 특별한 경우가 아니면 일단 무시해라.)

## 5. 계산 단계와 포멧팅 단계 분리하기 - 단계 쪼개기(6.11절)

### 개요

- 지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강했다.
- 이제 원하던 기능 변경, 즉 `statement()`의 HTML 버전을 만들어보자.
- 계산 코드가 모두 분리됐기 때문에 `statement()` 7줄에 대응하는 HTML 버전만 작성하면 된다.
- 단, 그 전에 중첩 함수를 같이 사용할 수 있게 `statement()`에서 분리해야 한다.

### 순서

1. 두 번째 단계가 될 코드 추출(`statement()` 본문 전체)
2. 중간 데이터 구조 객체 생성하고 각 정보를 중간 데이터 구조 객체에서 가져오도록 한다.
3. (반복문을 파이프라인으로 바꾸기(8.8절))
4. `statement()에 필요한 데이터 처리`에 해당하는 코드를 별도 함수로 분리한다. (`createStatementData()`)
5. 명확히 분리된 두 단계를 별도 파일에 저장한다.
6. HTML 버전을 작성한다.

### 점검

- 함수로 추출하면서 코드량이 늘었다.
- 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다.
- 이렇게 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다.
- 모듈화한 덕분에 계산 코드를 중복하지 않고도 HTML 버전을 만들 수 있었다.

## 6. 다형성을 활용해 계산 코드 재구성하기 - 조건부 로직을 다형성으로 바꾸기(10.4절)

### 개요

- 연극 장르를 추가하고 장르마다 공연료와 적립 포인트 계산법을 다르게 지정하도록 수정해보자.
- 현재 상태에서는 이 계산을 하는 함수에서 조건문을 수정해야 한다.
- 이를 객체지향의 다형성을 활용하는 방식으로 변경해보자.
- 상속 계층을 구성해서 희극/비극 서브클래스가 각자의 구체적인 계산 로직을 정의하도록 한다.
- 호출하는 쪽에서는 다형성 버전의 공연료 계산 함수를 호출하기만 하면 되고, 장르에 따라 다르게 계산하는 작업은 언어 차원에서 처리된다.
- 앞에서 수행한 리팩터링 덕분에 출력 포맷 관련 코드에는 신경쓰지 않아도 된다.

### 순서

1. 공연료 계산기 클래스 만들기
2. `amountFor()` 함수와 `volumeCreditsFor()` 함수를 공연료 계산기 클래스로 옮기기
3. 공연료 계산기를 다형성 버전으로 만들기 (타입 코드를 서브클래스로 바꾸기)

### 점검

- 연극 장르별 계산 코드를 함께 묶어두도록 변경했다.
- 이제 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 `createPerformanceCalculator()`에 추가하기만 하면 된다.

## 7. 마무리

- 리팩터링이 무엇인지, 왜 하는지, 어떻게 하는지 간단한 예를 통해 알아보았다.
- 이번 장에서는 크게 3단계로 리팩터링을 진행했다.
    1. 원본 함수를 중첩 함수 여러 개로 분리하기
    2. 단계 쪼개기를 적용하여 계산 코드와 출력 코드 분리하기
    3. 계산 로직으로 다형성으로 표현하기
- 각 단계에서 코드 구조를 보강했고, 이를 통해 코드가 수행하는 일이 더욱 분명하게 드러났다.
- 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
- 건강한 코드는 생산성을 극대화하고, 고객에게 필요한 기능을 더 빠르고 저렴한 비용으로 제공할 수 있게 한다.
- 코드를 건강하게 관리하려면 현재와 이상의 차이에 신경 쓰면서, 이상에 가까워지도록 리팩터링해야 한다.
- 이번 예시를 통해 리팩터링하는 리듬도 배울 수 있었다.
- 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.